//@version=6
// ════════════════════════════════════════════════════════════════════════
// StrategyLab BTC 15m v3 — Cross-Validated Weighted Composite
//
// Generated by StrategyLab optimizer
//   CV:   10.22%/month  (5-split walk-forward, months 12-24 tested)
//   Full: +100.11% / 24 months  (+2.63%/mo, Sharpe 0.85, DD -34%)
//
// 7 indicators, weighted combine, EMA-based calculations
// Matches Python backtest: expanding normalization, EMA-ATR, weighted sig
// ════════════════════════════════════════════════════════════════════════

strategy(
     "StrategyLab BTC 15m v3",
     overlay              = true,
     default_qty_type     = strategy.percent_of_equity,
     default_qty_value    = 70.6,                        // risk 19.5% × leverage 3.618
     initial_capital      = 10000,
     commission_type      = strategy.commission.percent,
     commission_value     = 0.04,                        // taker fee
     slippage             = 1,
     process_orders_on_close = false,                    // execute at next bar open (= 1-bar delay)
     pyramiding           = 0,
     margin_long          = 27.64,                       // 100 / 3.618
     margin_short         = 27.64)

// ════════════════════════════════════════════════════════════════════════
//  INPUTS
// ════════════════════════════════════════════════════════════════════════

// ── Indicator periods ──
i_st_period   = input.int   (17,     "Supertrend Period",    group = "Indicators")
i_st_mult     = input.float (3.883,  "Supertrend Mult",      step = 0.001, group = "Indicators")
i_adx_period  = input.int   (29,     "ADX Period",           group = "Indicators")
i_adxd_period = input.int   (15,     "ADX Dir Period",       group = "Indicators")
i_macd_fast   = input.int   (17,     "MACD Fast",            group = "Indicators")
i_macd_slow   = input.int   (37,     "MACD Slow",            group = "Indicators")
i_macd_sig    = input.int   (13,     "MACD Signal",          group = "Indicators")
i_roc_period  = input.int   (47,     "ROC Period",           group = "Indicators")
i_cci_period  = input.int   (13,     "CCI Period",           group = "Indicators")
i_mom_period  = input.int   (49,     "Momentum Period",      group = "Indicators")

// ── Weights (effective %: ST 21.9, ADX 19.5, CCI 20.6, Mom 20.5, MACD 14.5) ──
i_w1 = input.float(2.801,  "W: Supertrend",    step = 0.001, group = "Weights")
i_w2 = input.float(2.488,  "W: ADX",           step = 0.001, group = "Weights")
i_w3 = input.float(0.199,  "W: ADX Direction", step = 0.001, group = "Weights")
i_w4 = input.float(1.850,  "W: MACD Cross",    step = 0.001, group = "Weights")
i_w5 = input.float(0.190,  "W: ROC",           step = 0.001, group = "Weights")
i_w6 = input.float(2.628,  "W: CCI",           step = 0.001, group = "Weights")
i_w7 = input.float(2.624,  "W: Momentum",      step = 0.001, group = "Weights")

// ── Long thresholds ──
i_lt1 = input.float( 0.488, "L: Supertrend",    step = 0.001, group = "Long Thr")
i_lt2 = input.float( 0.302, "L: ADX",           step = 0.001, group = "Long Thr")
i_lt3 = input.float( 0.365, "L: ADX Dir",       step = 0.001, group = "Long Thr")
i_lt4 = input.float( 0.557, "L: MACD Cross",    step = 0.001, group = "Long Thr")
i_lt5 = input.float(-0.101, "L: ROC",           step = 0.001, group = "Long Thr")
i_lt6 = input.float( 0.377, "L: CCI",           step = 0.001, group = "Long Thr")
i_lt7 = input.float( 0.474, "L: Momentum",      step = 0.001, group = "Long Thr")

// ── Short thresholds ──
i_st_s1 = input.float(-0.591, "S: Supertrend",    step = 0.001, group = "Short Thr")
i_st_s2 = input.float(-0.961, "S: ADX",           step = 0.001, group = "Short Thr")
i_st_s3 = input.float(-0.966, "S: ADX Dir",       step = 0.001, group = "Short Thr")
i_st_s4 = input.float(-0.473, "S: MACD Cross",    step = 0.001, group = "Short Thr")
i_st_s5 = input.float( 0.064, "S: ROC",           step = 0.001, group = "Short Thr")
i_st_s6 = input.float(-0.353, "S: CCI",           step = 0.001, group = "Short Thr")
i_st_s7 = input.float(-0.938, "S: Momentum",      step = 0.001, group = "Short Thr")

// ── Combine ──
i_combine_thr = input.float(0.244, "Combine Threshold", step = 0.001, group = "Combine")

// ── Risk management ──
i_sl_pct    = input.float(6.807, "Stop Loss %",     step = 0.001, group = "Risk")
i_tp_pct    = input.float(6.788, "Take Profit %",   step = 0.001, group = "Risk")
i_trail_pct = input.float(4.735, "Trailing Stop %",  step = 0.001, group = "Risk")
i_max_hold  = input.int  (310,   "Max Hold Bars",                  group = "Risk")

// ── Time filter (UTC hours) ──
i_time_on   = input.bool(true, "Enable Time Filter", group = "Filter")
i_hour_s    = input.int (3,    "Hour Start (UTC)",    group = "Filter")
i_hour_e    = input.int (21,   "Hour End (UTC)",      group = "Filter")


// ════════════════════════════════════════════════════════════════════════
//  HELPER — FIXED-RANGE normalization to [-1, 1]
//
//  Uses hardcoded min/max from full 70,080-bar Python dataset.
//  This eliminates normalization drift between Python and TradingView.
// ════════════════════════════════════════════════════════════════════════
// Fixed ranges per indicator (from full dataset absolute min/max)
var float ADX_MIN = 5.934
var float ADX_MAX = 100.0
var float ROC_MIN = -14.425
var float ROC_MAX = 12.720
var float CCI_MIN = -273.079
var float CCI_MAX = 271.688
var float MOM_MIN = -0.14343
var float MOM_MAX = 0.12551

normFixed(float src, float mn, float mx) =>
    float mid = (mn + mx) / 2.0
    float hr  = (mx - mn) / 2.0
    hr > 0.0 ? math.max(-1.0, math.min(1.0, (src - mid) / hr)) : 0.0


// ════════════════════════════════════════════════════════════════════════
//  HELPER — DI+/DI- with EMA smoothing  (matches Python _atr → EMA)
// ════════════════════════════════════════════════════════════════════════
di_calc(int per) =>
    float um = high - nz(high[1])
    float dm = nz(low[1]) - low
    float pd = um > dm and um > 0 ? um : 0.0
    float md = dm > um and dm > 0 ? dm : 0.0
    float tr = math.max(high - low,
                 math.max(math.abs(high - nz(close[1])),
                          math.abs(low  - nz(close[1]))))
    float ae = ta.ema(tr, per)
    float pdi = ae > 0 ? 100.0 * ta.ema(pd, per) / ae : 0.0
    float mdi = ae > 0 ? 100.0 * ta.ema(md, per) / ae : 0.0
    [pdi, mdi]


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 1 — Supertrend  (BINARY ±1)
//  Custom implementation using EMA-ATR to match Python exactly.
//  Pine's built-in ta.supertrend uses RMA-ATR which differs.
// ════════════════════════════════════════════════════════════════════════
float _tr_st  = math.max(high - low,
                  math.max(math.abs(high - nz(close[1])),
                           math.abs(low  - nz(close[1]))))
float _atr_st = ta.ema(_tr_st, i_st_period)
float _b_up   = (high + low) / 2.0 - i_st_mult * _atr_st
float _b_dn   = (high + low) / 2.0 + i_st_mult * _atr_st

var float _f_up = 0.0
var float _f_dn = 0.0
var float _st_d = 1.0                                   // +1 = bull, -1 = bear

_f_up := _b_up > nz(_f_up[1]) or nz(close[1]) < nz(_f_up[1]) ? _b_up : nz(_f_up[1])
_f_dn := _b_dn < nz(_f_dn[1]) or nz(close[1]) > nz(_f_dn[1]) ? _b_dn : nz(_f_dn[1])

if close > nz(_f_dn[1])
    _st_d := 1.0
else if close < nz(_f_up[1])
    _st_d := -1.0

float ind1    = _st_d                                   // +1 bull, -1 bear
float st_line = _st_d == 1.0 ? _f_up : _f_dn           // for plotting


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 2 — ADX  (CONTINUOUS → normalize)
// ════════════════════════════════════════════════════════════════════════
[_pdi29, _mdi29] = di_calc(i_adx_period)
float _dx  = (_pdi29 + _mdi29) > 0 ? 100.0 * math.abs(_pdi29 - _mdi29) / (_pdi29 + _mdi29) : 0.0
float _adx = ta.ema(_dx, i_adx_period)
float ind2 = normFixed(_adx, ADX_MIN, ADX_MAX)


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 3 — ADX Direction  (BINARY ±1)
// ════════════════════════════════════════════════════════════════════════
[_pdi15, _mdi15] = di_calc(i_adxd_period)
float ind3 = _pdi15 > _mdi15 ? 1.0 : -1.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 4 — MACD Cross  (BINARY ±1)
// ════════════════════════════════════════════════════════════════════════
float _macd = ta.ema(close, i_macd_fast) - ta.ema(close, i_macd_slow)
float _msig = ta.ema(_macd, i_macd_sig)
float ind4  = _macd > _msig ? 1.0 : -1.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 5 — ROC  (CONTINUOUS → normalize)
//  ROC = pct_change(period) × 100
// ════════════════════════════════════════════════════════════════════════
float _roc = bar_index >= i_roc_period and nz(close[i_roc_period]) > 0
             ? (close - close[i_roc_period]) / close[i_roc_period] * 100.0
             : 0.0
float ind5 = normFixed(_roc, ROC_MIN, ROC_MAX)


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 6 — CCI  (CONTINUOUS → normalize)
//  CCI = (tp - SMA(tp)) / (0.015 × MAD)
//  MAD ≈ stdev × 0.7979   (matches Python vectorized approximation)
//  NOTE: Pine stdev uses population std; Python uses sample std.
//        Minor ~4% raw difference smoothed by expanding normalization.
// ════════════════════════════════════════════════════════════════════════
float _tp   = (high + low + close) / 3.0
float _sma  = ta.sma  (_tp, i_cci_period)
float _std  = ta.stdev(_tp, i_cci_period)
float _mad  = _std * 0.7979
float _cci  = _mad > 0 ? (_tp - _sma) / (0.015 * _mad) : 0.0
float ind6 = normFixed(_cci, CCI_MIN, CCI_MAX)


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 7 — Momentum  (CONTINUOUS → normalize)
//  momentum = pct_change(period)  (fractional, no ×100)
// ════════════════════════════════════════════════════════════════════════
float _mom = bar_index >= i_mom_period and nz(close[i_mom_period]) > 0
             ? (close - close[i_mom_period]) / close[i_mom_period]
             : 0.0
float ind7 = normFixed(_mom, MOM_MIN, MOM_MAX)


// ════════════════════════════════════════════════════════════════════════
//  WEIGHTED SIGNAL COMBINATION
//
//  Per indicator:
//    sig = value < short_thr ? −1            ← SHORT checked FIRST
//        : value > long_thr  ?  1              (matches Python where short overwrites long)
//        : 0
//
//  combined = Σ(sig_i × weight_i) / Σ(weight_i)
//  LONG  if combined >  threshold
//  SHORT if combined < −threshold
// ════════════════════════════════════════════════════════════════════════
ind_sig(float v, float lt, float st) =>
    v < st ? -1.0 : v > lt ? 1.0 : 0.0

float s1 = ind_sig(ind1, i_lt1, i_st_s1)
float s2 = ind_sig(ind2, i_lt2, i_st_s2)
float s3 = ind_sig(ind3, i_lt3, i_st_s3)
float s4 = ind_sig(ind4, i_lt4, i_st_s4)
float s5 = ind_sig(ind5, i_lt5, i_st_s5)
float s6 = ind_sig(ind6, i_lt6, i_st_s6)
float s7 = ind_sig(ind7, i_lt7, i_st_s7)

float w_sum = s1*i_w1 + s2*i_w2 + s3*i_w3 + s4*i_w4 + s5*i_w5 + s6*i_w6 + s7*i_w7
float w_tot = i_w1 + i_w2 + i_w3 + i_w4 + i_w5 + i_w6 + i_w7
float norm_sig = w_tot > 0 ? w_sum / w_tot : 0.0

int raw_signal = norm_sig > i_combine_thr ? 1 : norm_sig < -i_combine_thr ? -1 : 0


// ════════════════════════════════════════════════════════════════════════
//  TIME FILTER
// ════════════════════════════════════════════════════════════════════════
int utc_h     = hour(time, "UTC")
bool time_ok  = not i_time_on or (utc_h >= i_hour_s and utc_h < i_hour_e)
int filt_sig  = time_ok ? raw_signal : 0


// ════════════════════════════════════════════════════════════════════════
//  ENTRY — only from FLAT (no flip from long→short or short→long)
//
//  process_orders_on_close = false  →  order fills at NEXT bar's open
//  This provides the 1-bar delay matching Python's signal shift.
//  Do NOT add extra [1] offset.
// ════════════════════════════════════════════════════════════════════════
bool go_long  = filt_sig ==  1 and strategy.position_size == 0
bool go_short = filt_sig == -1 and strategy.position_size == 0

if go_long
    strategy.entry("Long",  strategy.long)
if go_short
    strategy.entry("Short", strategy.short)


// ════════════════════════════════════════════════════════════════════════
//  EXIT — SL / TP / Trailing / Max Hold
// ════════════════════════════════════════════════════════════════════════
if strategy.position_size > 0
    float ep   = strategy.position_avg_price
    float sl   = ep * (1.0 - i_sl_pct    / 100.0)
    float tp   = ep * (1.0 + i_tp_pct    / 100.0)
    int   toff = int(math.round(ep * i_trail_pct / 100.0 / syminfo.mintick))
    strategy.exit("LX", "Long", stop = sl, limit = tp,
                  trail_points = 1, trail_offset = toff)

if strategy.position_size < 0
    float ep   = strategy.position_avg_price
    float sl   = ep * (1.0 + i_sl_pct    / 100.0)
    float tp   = ep * (1.0 - i_tp_pct    / 100.0)
    int   toff = int(math.round(ep * i_trail_pct / 100.0 / syminfo.mintick))
    strategy.exit("SX", "Short", stop = sl, limit = tp,
                  trail_points = 1, trail_offset = toff)

// ── Max hold exit ──
var int hold_cnt = 0
if strategy.position_size != 0
    hold_cnt += 1
else
    hold_cnt := 0

if hold_cnt >= i_max_hold
    strategy.close_all("MaxHold")
    hold_cnt := 0


// ════════════════════════════════════════════════════════════════════════
//  VISUALS
// ════════════════════════════════════════════════════════════════════════
plot(st_line, "Supertrend", color = _st_d > 0 ? color.green : color.red, linewidth = 2)
bgcolor(filt_sig == 1  ? color.new(color.green, 92) :
        filt_sig == -1 ? color.new(color.red,   92) : na)

// Entry arrows
plotshape(go_long,  style = shape.triangleup,   location = location.belowbar,
          color = color.green, size = size.small, title = "Long")
plotshape(go_short, style = shape.triangledown, location = location.abovebar,
          color = color.red,   size = size.small, title = "Short")


// ════════════════════════════════════════════════════════════════════════
//  DASHBOARD
// ════════════════════════════════════════════════════════════════════════
var table dash = table.new(position.top_right, 3, 11,
                           bgcolor = color.new(color.black, 70), border_width = 1)

sig_clr(float v) => v > 0 ? color.green : v < 0 ? color.red : color.gray
sig_txt(float v) => v > 0 ? "LONG" : v < 0 ? "SHORT" : "—"

dashRow(int r, string nm, float val, float sg, string fmt) =>
    table.cell(dash, 0, r, nm,                          text_color = color.white, text_size = size.tiny)
    table.cell(dash, 1, r, str.tostring(val, fmt),      text_color = color.white, text_size = size.tiny)
    table.cell(dash, 2, r, sig_txt(sg),                 text_color = sig_clr(sg), text_size = size.tiny)

if barstate.islast
    table.cell(dash, 0, 0, "Indicator", text_color = color.white, text_size = size.small)
    table.cell(dash, 1, 0, "Value",     text_color = color.white, text_size = size.small)
    table.cell(dash, 2, 0, "Signal",    text_color = color.white, text_size = size.small)

    dashRow(1, "Supertrend", ind1, s1, "#.##")
    dashRow(2, "ADX",        ind2, s2, "#.###")
    dashRow(3, "ADX Dir",    ind3, s3, "#.##")
    dashRow(4, "MACD X",     ind4, s4, "#.##")
    dashRow(5, "ROC",        ind5, s5, "#.###")
    dashRow(6, "CCI",        ind6, s6, "#.###")
    dashRow(7, "Momentum",   ind7, s7, "#.###")

    // Combined row
    table.cell(dash, 0, 8, "COMBINED",  text_color = color.yellow, text_size = size.small)
    table.cell(dash, 1, 8, str.tostring(norm_sig, "#.###"), text_color = color.yellow, text_size = size.small)
    string cs = filt_sig > 0 ? "LONG" : filt_sig < 0 ? "SHORT" : "FLAT"
    color  cc = filt_sig > 0 ? color.green : filt_sig < 0 ? color.red : color.gray
    table.cell(dash, 2, 8, cs, text_color = cc, text_size = size.small)

    // Position info
    table.cell(dash, 0, 9, "Hold",  text_color = color.white,  text_size = size.tiny)
    table.cell(dash, 1, 9, str.tostring(hold_cnt) + "/" + str.tostring(i_max_hold),
               text_color = color.white, text_size = size.tiny)
    table.cell(dash, 2, 9, time_ok ? "Active" : "Filtered",
               text_color = time_ok ? color.green : color.orange, text_size = size.tiny)

    // PnL info
    table.cell(dash, 0, 10, "PnL", text_color = color.white, text_size = size.tiny)
    float pnl = strategy.netprofit
    table.cell(dash, 1, 10, str.tostring(pnl, "#.##"), text_color = pnl >= 0 ? color.green : color.red, text_size = size.tiny)
    table.cell(dash, 2, 10, str.tostring(pnl / strategy.initial_capital * 100, "#.#") + "%",
               text_color = pnl >= 0 ? color.green : color.red, text_size = size.tiny)


// ════════════════════════════════════════════════════════════════════════
//  ALERTS
// ════════════════════════════════════════════════════════════════════════
alertcondition(raw_signal ==  1 and raw_signal[1] !=  1, "Long Signal",  "StrategyLab v3: LONG")
alertcondition(raw_signal == -1 and raw_signal[1] != -1, "Short Signal", "StrategyLab v3: SHORT")
