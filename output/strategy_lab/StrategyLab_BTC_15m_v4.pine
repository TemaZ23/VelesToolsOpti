//@version=6
// ════════════════════════════════════════════════════════════════════════
// StrategyLab BTC 15m v4 — Cross-Validated Vote Composite
//
// Generated by StrategyLab optimizer v2 (expanded indicator set)
//   CV Score: 37.08  (5-split walk-forward, all OOS)
//   CV Median: 39.48%/month  |  Mean: 38.46%/month
//   CV Splits: [64.4%, 24.8%, 18.3%, 45.2%, 39.5%]  — ALL positive
//   Worst Split: +18.3%/month
//   CV DD: -9.0%  |  Sharpe: 8.99  |  PF: 3.65  |  WR: 59.3%
//
// 7 indicators, VOTE combination, 6x leverage
// Uses SMA-based HMA and EMA-based RSI/ATR to match Python exactly
// Fixed-range normalization for continuous indicators
// ════════════════════════════════════════════════════════════════════════

strategy(
     "StrategyLab BTC 15m v4",
     overlay              = true,
     default_qty_type     = strategy.percent_of_equity,
     default_qty_value    = 116.5,                       // risk 19.41% × leverage 6.0
     initial_capital      = 10000,
     commission_type      = strategy.commission.percent,
     commission_value     = 0.04,                        // taker fee
     slippage             = 1,
     process_orders_on_close = false,                    // 1-bar delay (matches Python)
     pyramiding           = 0,
     margin_long          = 16.67,                       // 100 / 6.0
     margin_short         = 16.67)


// ════════════════════════════════════════════════════════════════════════
//  INPUTS
// ════════════════════════════════════════════════════════════════════════

// ── 1. Hull MA (SMA-based direction) ──
i_hma_period = input.int  (11,     "Period",    group = "1. Hull MA")
i_hma_lt     = input.float(-0.251, "Long Thr",  step = 0.001, group = "1. Hull MA")
i_hma_st     = input.float( 0.441, "Short Thr", step = 0.001, group = "1. Hull MA")

// ── 2. RSI Signal (EMA-based) ──
i_rsi_period = input.int  (26,     "Period",     group = "2. RSI Signal")
i_rsi_os     = input.float(23.0,   "Oversold",   group = "2. RSI Signal")
i_rsi_ob     = input.float(74.0,   "Overbought", group = "2. RSI Signal")
i_rsi_lt     = input.float( 0.461, "Long Thr",   step = 0.001, group = "2. RSI Signal")
i_rsi_st     = input.float(-0.589, "Short Thr",  step = 0.001, group = "2. RSI Signal")

// ── 3. Stochastic Signal ──
i_sto_k    = input.int  (9,      "K Period",   group = "3. Stochastic")
i_sto_d    = input.int  (7,      "D Period",   group = "3. Stochastic")
i_sto_low  = input.float(18.0,   "Low Level",  group = "3. Stochastic")
i_sto_high = input.float(80.0,   "High Level", group = "3. Stochastic")
i_sto_lt   = input.float( 0.382, "Long Thr",   step = 0.001, group = "3. Stochastic")
i_sto_st   = input.float(-0.946, "Short Thr",  step = 0.001, group = "3. Stochastic")

// ── 4. ROC (continuous, normalized) ──
i_roc_period = input.int  (12,     "Period",    group = "4. ROC")
i_roc_lt     = input.float(-0.307, "Long Thr",  step = 0.001, group = "4. ROC")
i_roc_st     = input.float(-0.875, "Short Thr", step = 0.001, group = "4. ROC")

// ── 5. Squeeze (BB inside Keltner) ──
i_sqz_bb   = input.int  (29,    "BB Period",  group = "5. Squeeze")
i_sqz_kc   = input.int  (12,    "KC Period",  group = "5. Squeeze")
i_sqz_mult = input.float(1.169, "KC Mult",    step = 0.001, group = "5. Squeeze")
i_sqz_lt   = input.float(0.835, "Long Thr",   step = 0.001, group = "5. Squeeze")
i_sqz_st   = input.float(0.197, "Short Thr",  step = 0.001, group = "5. Squeeze")

// ── 6. Basis (spot-futures) ──
// NOTE: With long_thr=0.426 / short_thr=-0.535, basis rarely triggers
// (typical basis amplitude < 1%). Included for completeness.
i_basis_sym = input.string("BINANCE:BTCUSDT", "Spot Symbol", group = "6. Basis")
i_basis_lt  = input.float( 0.426,  "Long Thr",  step = 0.001, group = "6. Basis")
i_basis_st  = input.float(-0.535,  "Short Thr", step = 0.001, group = "6. Basis")

// ── 7. Multi-Timeframe EMA 4h ──
i_mtf_fast = input.int  (10,     "EMA Fast",  group = "7. MTF EMA 4h")
i_mtf_slow = input.int  (34,     "EMA Slow",  group = "7. MTF EMA 4h")
i_mtf_lt   = input.float( 0.016, "Long Thr",  step = 0.001, group = "7. MTF EMA 4h")
i_mtf_st   = input.float(-0.954, "Short Thr", step = 0.001, group = "7. MTF EMA 4h")

// ── Vote combine ──
i_combine_thr = input.float(0.282, "Vote Threshold (×N)",
                            tooltip = "majority = N_indicators × threshold",
                            step = 0.001, group = "Combine")

// ── Risk management ──
i_sl_pct    = input.float(6.867,  "Stop Loss %",         step = 0.001, group = "Risk")
i_tp_pct    = input.float(6.124,  "Take Profit %",       step = 0.001, group = "Risk")
i_trail_pct = input.float(3.198,  "Trailing Stop %",     step = 0.001, group = "Risk")
i_max_hold  = input.int  (41,     "Max Hold Bars",                     group = "Risk")
i_flip_exit = input.bool (true,   "Exit on Signal Flip",              group = "Risk")

// ── Time filter (UTC hours) ──
i_time_on = input.bool(true, "Enable Time Filter", group = "Filter")
i_hour_s  = input.int (10,  "Hour Start (UTC)",    group = "Filter")
i_hour_e  = input.int (21,  "Hour End (UTC)",      group = "Filter")


// ════════════════════════════════════════════════════════════════════════
//  HELPERS
// ════════════════════════════════════════════════════════════════════════

// Fixed-range normalization to [-1, 1]
normFixed(float src, float mn, float mx) =>
    float mid = (mn + mx) / 2.0
    float hr  = (mx - mn) / 2.0
    hr > 0.0 ? math.max(-1.0, math.min(1.0, (src - mid) / hr)) : 0.0

// EMA-based RSI (matches Python: ewm(span=period, adjust=False))
// Pine ta.rsi uses RMA — different smoothing. Must use custom.
rsi_ema(float src, int period) =>
    float chg = nz(src) - nz(src[1])
    float up  = math.max(chg, 0.0)
    float dn  = math.max(-chg, 0.0)
    float up_avg = ta.ema(up, period)
    float dn_avg = ta.ema(dn, period)
    dn_avg < 1e-10 ? 100.0 : 100.0 - 100.0 / (1.0 + up_avg / dn_avg)

// EMA-based ATR (matches Python _atr using ewm)
// Pine ta.atr uses RMA — different from Python. Must use custom.
atr_ema(int period) =>
    float tr_ = math.max(high - low,
                  math.max(math.abs(high - nz(close[1])),
                           math.abs(low  - nz(close[1]))))
    ta.ema(tr_, period)

// Vote: SHORT checked first (matches Python where short overwrites long)
vote(float v, float lt, float st) =>
    v < st ? -1.0 : v > lt ? 1.0 : 0.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 1 — Hull MA Trend (SMA-based to match Python)
//
//  Python uses .rolling().mean() = SMA, not WMA.
//  Direction: +1 rising, -1 falling.
// ════════════════════════════════════════════════════════════════════════
int _hma_half  = math.max(2, i_hma_period / 2)
int _hma_sqrt  = math.max(2, int(math.sqrt(i_hma_period)))
float _sma_h   = ta.sma(close, _hma_half)
float _sma_f   = ta.sma(close, i_hma_period)
float _hma_d   = 2.0 * _sma_h - _sma_f
float _hma_val = ta.sma(_hma_d, _hma_sqrt)
float ind1     = nz(_hma_val) > nz(nz(_hma_val)[1]) ? 1.0 : -1.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 2 — RSI Signal (EMA-based)
//
//  +1 when RSI < oversold (buy signal)
//  -1 when RSI > overbought (sell signal)
//   0 otherwise
// ════════════════════════════════════════════════════════════════════════
float _rsi = rsi_ema(close, i_rsi_period)
float ind2 = _rsi < i_rsi_os ? 1.0 : _rsi > i_rsi_ob ? -1.0 : 0.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 3 — Stochastic Signal
//
//  K = 100 × (close − lowest) / (highest − lowest)
//  D = SMA(K, d_period)   — matches Python .rolling().mean()
//  +1 when K < low AND K > D  (oversold + K crossing up over D)
//  -1 when K > high AND K < D (overbought + K crossing down under D)
// ════════════════════════════════════════════════════════════════════════
float _sk_lo = ta.lowest (low,  i_sto_k)
float _sk_hi = ta.highest(high, i_sto_k)
float _sk_rn = _sk_hi - _sk_lo
float _sk_k  = _sk_rn > 0.0 ? 100.0 * (close - _sk_lo) / _sk_rn : 50.0
float _sk_d  = ta.sma(_sk_k, i_sto_d)
float ind3   = _sk_k < i_sto_low  and _sk_k > _sk_d ? 1.0 :
               _sk_k > i_sto_high and _sk_k < _sk_d ? -1.0 : 0.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 4 — ROC (Rate of Change)
//
//  Continuous indicator → normalize with fixed range
//  ROC = (close − close[period]) / close[period] × 100
//  Fixed range: [-14.425, 12.720] from full Python dataset
// ════════════════════════════════════════════════════════════════════════
var float ROC_MIN = -14.425
var float ROC_MAX =  12.720

float _roc_raw = bar_index >= i_roc_period and nz(close[i_roc_period]) > 0
                 ? (close - close[i_roc_period]) / close[i_roc_period] * 100.0
                 : 0.0
float ind4 = normFixed(_roc_raw, ROC_MIN, ROC_MAX)


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 5 — Squeeze (Bollinger inside Keltner)
//
//  BB: SMA ± 2×std  (using sample std to match Python)
//  KC: EMA ± mult×ATR_EMA
//  Squeeze = 1 if BB fully inside KC, else 0
// ════════════════════════════════════════════════════════════════════════
float _sqz_sma = ta.sma(close, i_sqz_bb)
// Convert Pine's population stdev → sample stdev (matching Python rolling().std())
float _sqz_std = ta.stdev(close, i_sqz_bb) * math.sqrt(float(i_sqz_bb) / float(i_sqz_bb - 1))
float _sqz_bbu = _sqz_sma + 2.0 * _sqz_std
float _sqz_bbl = _sqz_sma - 2.0 * _sqz_std
float _sqz_ema = ta.ema(close, i_sqz_kc)
float _sqz_atr = atr_ema(i_sqz_kc)
float _sqz_kcu = _sqz_ema + i_sqz_mult * _sqz_atr
float _sqz_kcl = _sqz_ema - i_sqz_mult * _sqz_atr
float ind5     = _sqz_bbl > _sqz_kcl and _sqz_bbu < _sqz_kcu ? 1.0 : 0.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 6 — Basis (spot − futures premium)
//
//  basis = (close_futures − close_spot) / close_spot
//  Typically < 1%, so with thresholds 0.426 / −0.535 this almost
//  never votes. Included for faithful strategy reproduction.
// ════════════════════════════════════════════════════════════════════════
float _spot = request.security(i_basis_sym, timeframe.period, close)
float ind6  = nz(_spot) > 0.0 ? (close - _spot) / _spot : 0.0


// ════════════════════════════════════════════════════════════════════════
//  INDICATOR 7 — Multi-Timeframe EMA 4h Cross
//
//  Uses 4h close forward-filled to 15m bars.
//  EMA is computed on every 15m bar (matching Python merge_asof).
//  +1 if fast EMA > slow EMA, −1 otherwise
// ════════════════════════════════════════════════════════════════════════
float _c4h     = request.security(syminfo.tickerid, "240", close)
float _mtf_ef  = ta.ema(_c4h, i_mtf_fast)
float _mtf_es  = ta.ema(_c4h, i_mtf_slow)
float ind7     = _mtf_ef > _mtf_es ? 1.0 : -1.0


// ════════════════════════════════════════════════════════════════════════
//  VOTE COMBINATION
//
//  Each indicator → +1 / 0 / −1 vote (via threshold comparison)
//  vote_sum = Σ votes   (weights NOT used in vote mode)
//  majority = n_indicators × combine_threshold = 7 × 0.282 ≈ 1.97
//
//  LONG  if vote_sum >  majority  (need ≥ 2 long votes)
//  SHORT if vote_sum < −majority  (need ≥ 2 short votes)
// ════════════════════════════════════════════════════════════════════════
float v1 = vote(ind1, i_hma_lt,   i_hma_st)
float v2 = vote(ind2, i_rsi_lt,   i_rsi_st)
float v3 = vote(ind3, i_sto_lt,   i_sto_st)
float v4 = vote(ind4, i_roc_lt,   i_roc_st)
float v5 = vote(ind5, i_sqz_lt,   i_sqz_st)
float v6 = vote(ind6, i_basis_lt, i_basis_st)
float v7 = vote(ind7, i_mtf_lt,   i_mtf_st)

float vote_sum = v1 + v2 + v3 + v4 + v5 + v6 + v7
float majority = 7.0 * i_combine_thr

int raw_signal = vote_sum > majority ? 1 : vote_sum < -majority ? -1 : 0


// ════════════════════════════════════════════════════════════════════════
//  TIME FILTER
// ════════════════════════════════════════════════════════════════════════
int  utc_h   = hour(time, "UTC")
bool time_ok = not i_time_on or (utc_h >= i_hour_s and utc_h < i_hour_e)
int  filt_sig = time_ok ? raw_signal : 0


// ════════════════════════════════════════════════════════════════════════
//  ENTRY — only from FLAT (no pyramiding, no flip)
//
//  process_orders_on_close = false → fills at next bar's open
//  This provides the 1-bar delay matching Python's signal shift.
// ════════════════════════════════════════════════════════════════════════
bool go_long  = filt_sig ==  1 and strategy.position_size == 0
bool go_short = filt_sig == -1 and strategy.position_size == 0

if go_long
    strategy.entry("Long",  strategy.long)
if go_short
    strategy.entry("Short", strategy.short)


// ════════════════════════════════════════════════════════════════════════
//  EXIT — SL / TP / Trailing / Signal Flip / Max Hold
//
//  Priority in Python: SL → TP → Trailing → SignalFlip → MaxHold
//  In TV: strategy.exit (SL/TP/Trailing) executes first,
//         then strategy.close (Flip/MaxHold) if no exit triggered.
// ════════════════════════════════════════════════════════════════════════

// ── SL / TP / Trailing ──
if strategy.position_size > 0
    float ep   = strategy.position_avg_price
    float sl   = ep * (1.0 - i_sl_pct    / 100.0)
    float tp   = ep * (1.0 + i_tp_pct    / 100.0)
    int   toff = int(math.round(ep * i_trail_pct / 100.0 / syminfo.mintick))
    strategy.exit("LX", "Long",  stop = sl, limit = tp,
                  trail_points = 1, trail_offset = toff)

if strategy.position_size < 0
    float ep   = strategy.position_avg_price
    float sl   = ep * (1.0 + i_sl_pct    / 100.0)
    float tp   = ep * (1.0 - i_tp_pct    / 100.0)
    int   toff = int(math.round(ep * i_trail_pct / 100.0 / syminfo.mintick))
    strategy.exit("SX", "Short", stop = sl, limit = tp,
                  trail_points = 1, trail_offset = toff)

// ── Signal flip exit ──
if i_flip_exit
    if strategy.position_size > 0 and filt_sig == -1
        strategy.close("Long",  comment = "SignalFlip")
    if strategy.position_size < 0 and filt_sig ==  1
        strategy.close("Short", comment = "SignalFlip")

// ── Max hold exit ──
var int hold_cnt = 0
if strategy.position_size != 0
    hold_cnt += 1
else
    hold_cnt := 0

if hold_cnt >= i_max_hold
    strategy.close_all("MaxHold")
    hold_cnt := 0


// ════════════════════════════════════════════════════════════════════════
//  VISUALS
// ════════════════════════════════════════════════════════════════════════
color hma_c = ind1 > 0 ? color.green : color.red
plot(_hma_val, "HMA", color = hma_c, linewidth = 2)

bgcolor(filt_sig == 1  ? color.new(color.green, 92) :
        filt_sig == -1 ? color.new(color.red,   92) : na)

plotshape(go_long,  style = shape.triangleup,   location = location.belowbar,
          color = color.green, size = size.small, title = "Long Entry")
plotshape(go_short, style = shape.triangledown, location = location.abovebar,
          color = color.red,   size = size.small, title = "Short Entry")

// Squeeze dots on zero line (purple = squeeze on)
plot(ind5 > 0 ? low * 0.999 : na, "Squeeze", style = plot.style_circles,
     color = color.new(color.purple, 30), linewidth = 3)


// ════════════════════════════════════════════════════════════════════════
//  DASHBOARD
// ════════════════════════════════════════════════════════════════════════
var table dash = table.new(position.top_right, 3, 13,
                           bgcolor = color.new(color.black, 70), border_width = 1)

sig_clr(float v) => v > 0 ? color.green : v < 0 ? color.red : color.gray
sig_txt(float v) => v > 0 ? "▲ L" : v < 0 ? "▼ S" : "—"

dashRow(int r, string nm, string val_str, float vt) =>
    table.cell(dash, 0, r, nm,      text_color = color.white,    text_size = size.tiny)
    table.cell(dash, 1, r, val_str, text_color = color.white,    text_size = size.tiny)
    table.cell(dash, 2, r, sig_txt(vt), text_color = sig_clr(vt), text_size = size.tiny)

if barstate.islast
    table.cell(dash, 0, 0, "Indicator", text_color = color.white,  text_size = size.small)
    table.cell(dash, 1, 0, "Value",     text_color = color.white,  text_size = size.small)
    table.cell(dash, 2, 0, "Vote",      text_color = color.white,  text_size = size.small)

    dashRow(1, "HullMA",   str.tostring(ind1, "#.#"),                         v1)
    dashRow(2, "RSI Sig",  str.tostring(_rsi, "#.#"),                         v2)
    dashRow(3, "Stoch",    str.tostring(_sk_k, "#.#") + "/" + str.tostring(_sk_d, "#.#"), v3)
    dashRow(4, "ROC",      str.tostring(ind4, "#.###"),                       v4)
    dashRow(5, "Squeeze",  ind5 > 0 ? "ON" : "OFF",                          v5)
    dashRow(6, "Basis",    str.tostring(ind6 * 100.0, "#.####") + "%",        v6)
    dashRow(7, "MTF 4h",   str.tostring(ind7, "#.#"),                         v7)

    table.cell(dash, 0, 8, "", text_color = color.white, text_size = size.tiny)

    // ── Combined ──
    table.cell(dash, 0, 9, "VOTES",  text_color = color.yellow, text_size = size.small)
    table.cell(dash, 1, 9, str.tostring(vote_sum, "#.#") + " / " + str.tostring(majority, "#.##"),
               text_color = color.yellow, text_size = size.small)
    string cs_ = filt_sig > 0 ? "LONG" : filt_sig < 0 ? "SHORT" : "FLAT"
    color  cc_ = filt_sig > 0 ? color.green : filt_sig < 0 ? color.red : color.gray
    table.cell(dash, 2, 9, cs_, text_color = cc_, text_size = size.small)

    // ── Hold ──
    table.cell(dash, 0, 10, "Hold",  text_color = color.white,  text_size = size.tiny)
    table.cell(dash, 1, 10, str.tostring(hold_cnt) + "/" + str.tostring(i_max_hold),
               text_color = color.white, text_size = size.tiny)
    table.cell(dash, 2, 10, time_ok ? "Active" : "Filtered",
               text_color = time_ok ? color.green : color.orange, text_size = size.tiny)

    // ── PnL ──
    table.cell(dash, 0, 11, "PnL",  text_color = color.white, text_size = size.tiny)
    float pnl = strategy.netprofit
    table.cell(dash, 1, 11, str.tostring(pnl, "#.##"),
               text_color = pnl >= 0 ? color.green : color.red, text_size = size.tiny)
    table.cell(dash, 2, 11, str.tostring(pnl / strategy.initial_capital * 100, "#.#") + "%",
               text_color = pnl >= 0 ? color.green : color.red, text_size = size.tiny)


// ════════════════════════════════════════════════════════════════════════
//  ALERTS
// ════════════════════════════════════════════════════════════════════════
alertcondition(raw_signal ==  1 and raw_signal[1] !=  1, "Long Signal",  "StrategyLab v4: LONG")
alertcondition(raw_signal == -1 and raw_signal[1] != -1, "Short Signal", "StrategyLab v4: SHORT")
alertcondition(strategy.position_size == 0 and strategy.position_size[1] != 0,
               "Position Closed", "StrategyLab v4: FLAT")
