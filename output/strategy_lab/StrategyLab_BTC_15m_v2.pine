// This Pine Script™ source code is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/
// © Strategy Lab — Self-Improving Trading Strategy
// Generated by Strategy Lab Optimizer (Cross-Validated Walk-Forward)
//
// РЕЗУЛЬТАТЫ ОПТИМИЗАЦИИ (2 года, 70,080 баров @15m BTC):
//   Cross-validated: 130%/мес (median по 3 сплитам)
//   Full validation:  168%/мес, DD -19.2%, WR 85.1%, Sharpe 4.92
//   Profit Factor: 3.91, 12,648 сделок
//
// ИНДИКАТОРЫ (vote mode, threshold 0.20):
//   1. EMA Distance (100)   — weight 2.77
//   2. SuperTrend (8, 2.30) — weight 1.58
//   3. LR Slope (91)        — weight 1.80
//   4. RSI (13)             — weight 2.84
//   5. MACD Signal (15,26,8)— weight 1.33
//   6. MACD Cross (9,37,7)  — weight 0.41
//   7. ROC (23)             — weight 2.71

//@version=6
strategy("Strategy Lab BTC 15m v2", 
     overlay=true, 
     default_qty_type=strategy.percent_of_equity, 
     default_qty_value=17.5,
     initial_capital=10000,
     currency=currency.USD,
     commission_type=strategy.commission.percent,
     commission_value=0.04,
     slippage=3,
     pyramiding=0,
     calc_on_every_tick=false,
     process_orders_on_close=false,
     max_bars_back=500)

// ══════════════════════════════════════════════════════════════════
// INPUTS — Optimized Parameters
// ══════════════════════════════════════════════════════════════════

// -- Risk Management --
i_leverage      = input.float(5.27,  "Leverage",            minval=1, maxval=20, step=0.01, group="Risk")
i_sl_pct        = input.float(2.01,  "Stop Loss %",         minval=0.5, maxval=20, step=0.01, group="Risk")
i_tp_pct        = input.float(19.98, "Take Profit %",       minval=1, maxval=50, step=0.01, group="Risk")
i_trail_pct     = input.float(0.002, "Trailing Stop %",     minval=0, maxval=5, step=0.001, group="Risk")
i_max_hold      = input.int(271,     "Max Hold Bars",       minval=0, maxval=500, group="Risk")
i_risk_pct      = input.float(17.53, "Risk Per Trade %",    minval=1, maxval=50, step=0.01, group="Risk")
i_exit_flip     = input.bool(false,  "Exit On Signal Flip", group="Risk")

// -- Combine --
i_threshold     = input.float(0.201, "Vote Threshold",      minval=0, maxval=1, step=0.001, group="Combine")

// -- Indicator 1: EMA Distance --
i_emad_period   = input.int(100,    "EMA Distance Period",  minval=5, maxval=200, group="1. EMA Dist")
i_emad_w        = input.float(2.774, "Weight",              minval=0, maxval=5, step=0.001, group="1. EMA Dist")
i_emad_long     = input.float(0.307, "Long Thr",            minval=-1, maxval=1, step=0.001, group="1. EMA Dist")
i_emad_short    = input.float(-0.384, "Short Thr",          minval=-1, maxval=1, step=0.001, group="1. EMA Dist")

// -- Indicator 2: SuperTrend --
i_st_period     = input.int(8,       "Period",              minval=2, maxval=50, group="2. SuperTrend")
i_st_mult       = input.float(2.297, "Multiplier",          minval=0.5, maxval=10, step=0.001, group="2. SuperTrend")
i_st_w          = input.float(1.579, "Weight",              minval=0, maxval=5, step=0.001, group="2. SuperTrend")
i_st_long       = input.float(-0.450, "Long Thr",           minval=-1, maxval=1, step=0.001, group="2. SuperTrend")
i_st_short      = input.float(0.478,  "Short Thr",          minval=-1, maxval=1, step=0.001, group="2. SuperTrend")

// -- Indicator 3: LR Slope --
i_lr_period     = input.int(91,      "Period",              minval=5, maxval=200, group="3. LR Slope")
i_lr_w          = input.float(1.797, "Weight",              minval=0, maxval=5, step=0.001, group="3. LR Slope")
i_lr_long       = input.float(-0.423, "Long Thr",           minval=-1, maxval=1, step=0.001, group="3. LR Slope")
i_lr_short      = input.float(0.448,  "Short Thr",          minval=-1, maxval=1, step=0.001, group="3. LR Slope")

// -- Indicator 4: RSI --
i_rsi_period    = input.int(13,      "Period",              minval=5, maxval=50, group="4. RSI")
i_rsi_w         = input.float(2.844, "Weight",              minval=0, maxval=5, step=0.001, group="4. RSI")
i_rsi_long      = input.float(0.341, "Long Thr",            minval=-1, maxval=1, step=0.001, group="4. RSI")
i_rsi_short     = input.float(0.404, "Short Thr",           minval=-1, maxval=1, step=0.001, group="4. RSI")

// -- Indicator 5: MACD Signal (histogram) --
i_ms_fast       = input.int(15,      "Fast",                minval=5, maxval=30, group="5. MACD Signal")
i_ms_slow       = input.int(26,      "Slow",                minval=15, maxval=50, group="5. MACD Signal")
i_ms_sig        = input.int(8,       "Signal",              minval=2, maxval=20, group="5. MACD Signal")
i_ms_w          = input.float(1.331, "Weight",              minval=0, maxval=5, step=0.001, group="5. MACD Signal")
i_ms_long       = input.float(0.236, "Long Thr",            minval=-1, maxval=1, step=0.001, group="5. MACD Signal")
i_ms_short      = input.float(-0.805, "Short Thr",          minval=-1, maxval=1, step=0.001, group="5. MACD Signal")

// -- Indicator 6: MACD Cross --
i_mc_fast       = input.int(9,       "Fast",                minval=5, maxval=30, group="6. MACD Cross")
i_mc_slow       = input.int(37,      "Slow",                minval=15, maxval=50, group="6. MACD Cross")
i_mc_sig        = input.int(7,       "Signal",              minval=2, maxval=20, group="6. MACD Cross")
i_mc_w          = input.float(0.414, "Weight",              minval=0, maxval=5, step=0.001, group="6. MACD Cross")
i_mc_long       = input.float(-0.358, "Long Thr",           minval=-1, maxval=1, step=0.001, group="6. MACD Cross")
i_mc_short      = input.float(0.496,  "Short Thr",          minval=-1, maxval=1, step=0.001, group="6. MACD Cross")

// -- Indicator 7: ROC --
i_roc_period    = input.int(23,      "Period",              minval=5, maxval=50, group="7. ROC")
i_roc_w         = input.float(2.708, "Weight",              minval=0, maxval=5, step=0.001, group="7. ROC")
i_roc_long      = input.float(-0.092, "Long Thr",           minval=-1, maxval=1, step=0.001, group="7. ROC")
i_roc_short     = input.float(-0.081, "Short Thr",          minval=-1, maxval=1, step=0.001, group="7. ROC")

// -- Volume Filter --
i_vol_filter    = input.bool(true,   "Volume Filter",       group="Filters")
i_vol_period    = input.int(72,      "Vol Z-Score Period",  minval=10, maxval=200, group="Filters")
i_vol_min_z     = input.float(-1.249, "Min Vol Z-Score",    minval=-3, maxval=3, step=0.001, group="Filters")

// ══════════════════════════════════════════════════════════════════
// EXPANDING NORMALIZATION — matches Python _normalize_to_unit()
// Track all-time min/max per indicator with `var` keyword
// ══════════════════════════════════════════════════════════════════
expand_normalize(float src, float prev_min, float prev_max) =>
    float new_min = na(prev_min) ? src : math.min(prev_min, src)
    float new_max = na(prev_max) ? src : math.max(prev_max, src)
    float rng = new_max - new_min
    float mid = (new_min + new_max) / 2.0
    float half = rng / 2.0
    float norm = half != 0 ? math.max(-1.0, math.min(1.0, (src - mid) / half)) : 0.0
    [norm, new_min, new_max]

// ══════════════════════════════════════════════════════════════════
// INDICATOR 1: EMA Distance — normalized continuous
// (close - EMA) / EMA → expanding normalized to [-1, 1]
// ══════════════════════════════════════════════════════════════════
emad_ema = ta.ema(close, i_emad_period)
emad_raw = (close - emad_ema) / emad_ema

var float emad_min = na
var float emad_max = na
[emad_val, emad_min_new, emad_max_new] = expand_normalize(emad_raw, emad_min, emad_max)
emad_min := emad_min_new
emad_max := emad_max_new

// ══════════════════════════════════════════════════════════════════
// INDICATOR 2: SuperTrend — binary {-1, +1}
// ══════════════════════════════════════════════════════════════════
[st_line, st_dir] = ta.supertrend(i_st_mult, i_st_period)
supertrend_val = st_dir < 0 ? 1.0 : -1.0  // Pine: -1=uptrend, 1=downtrend

// ══════════════════════════════════════════════════════════════════
// INDICATOR 3: LR Slope — normalized continuous
// Python: slope / y_mean (price-normalized slope of linear regression)
// Pine: diff of linreg one bar apart = slope; divide by close ≈ / y_mean
// ══════════════════════════════════════════════════════════════════
lr_slope_raw = ta.linreg(close, i_lr_period, 0) - ta.linreg(close, i_lr_period, 1)
lr_raw = lr_slope_raw / close

var float lr_min = na
var float lr_max = na
[lr_val, lr_min_new, lr_max_new] = expand_normalize(lr_raw, lr_min, lr_max)
lr_min := lr_min_new
lr_max := lr_max_new

// ══════════════════════════════════════════════════════════════════
// INDICATOR 4: RSI — normalized continuous (0-100 → [-1,1])
// ══════════════════════════════════════════════════════════════════
rsi_raw = ta.rsi(close, i_rsi_period)

var float rsi_min = na
var float rsi_max = na
[rsi_val, rsi_min_new, rsi_max_new] = expand_normalize(rsi_raw, rsi_min, rsi_max)
rsi_min := rsi_min_new
rsi_max := rsi_max_new

// ══════════════════════════════════════════════════════════════════
// INDICATOR 5: MACD Signal (histogram normalized)
// macd_hist / close * 1000 → expanding normalized
// ══════════════════════════════════════════════════════════════════
ms_macd = ta.ema(close, i_ms_fast) - ta.ema(close, i_ms_slow)
ms_signal = ta.ema(ms_macd, i_ms_sig)
ms_hist_raw = (ms_macd - ms_signal) / close * 1000

var float ms_min = na
var float ms_max = na
[ms_val, ms_min_new, ms_max_new] = expand_normalize(ms_hist_raw, ms_min, ms_max)
ms_min := ms_min_new
ms_max := ms_max_new

// ══════════════════════════════════════════════════════════════════
// INDICATOR 6: MACD Cross — binary {-1, +1}
// ══════════════════════════════════════════════════════════════════
mc_macd = ta.ema(close, i_mc_fast) - ta.ema(close, i_mc_slow)
mc_signal = ta.ema(mc_macd, i_mc_sig)
macd_cross_val = mc_macd > mc_signal ? 1.0 : -1.0

// ══════════════════════════════════════════════════════════════════
// INDICATOR 7: ROC — normalized continuous
// close.pct_change(period) * 100 → expanding normalized
// ══════════════════════════════════════════════════════════════════
roc_raw = (close - close[i_roc_period]) / close[i_roc_period] * 100

var float roc_min = na
var float roc_max = na
[roc_val, roc_min_new, roc_max_new] = expand_normalize(roc_raw, roc_min, roc_max)
roc_min := roc_min_new
roc_max := roc_max_new

// ══════════════════════════════════════════════════════════════════
// VOLUME FILTER
// Volume Z-Score: (vol - mean) / std < threshold → filter out
// ══════════════════════════════════════════════════════════════════
vol_mean = ta.sma(volume, i_vol_period)
vol_std  = ta.stdev(volume, i_vol_period)
vol_z    = vol_std != 0 ? (volume - vol_mean) / vol_std : 0.0
vol_ok   = not i_vol_filter or vol_z >= i_vol_min_z

// ══════════════════════════════════════════════════════════════════
// VOTE SIGNAL COMBINATION
// Each indicator votes: +1 (long), -1 (short), 0 (neutral)
// If indicator value > long_threshold → long vote
// If indicator value < short_threshold → short vote
// Total votes / n_indicators compared to threshold
// ══════════════════════════════════════════════════════════════════

// Individual votes — SHORT checked FIRST (matches Python where short overwrites long)
emad_vote = emad_val < i_emad_short ? -1.0 : emad_val > i_emad_long ? 1.0 : 0.0
st_vote   = supertrend_val < i_st_short ? -1.0 : supertrend_val > i_st_long ? 1.0 : 0.0
lr_vote   = lr_val < i_lr_short ? -1.0 : lr_val > i_lr_long ? 1.0 : 0.0
rsi_vote  = rsi_val < i_rsi_short ? -1.0 : rsi_val > i_rsi_long ? 1.0 : 0.0
ms_vote   = ms_val < i_ms_short ? -1.0 : ms_val > i_ms_long ? 1.0 : 0.0
mc_vote   = macd_cross_val < i_mc_short ? -1.0 : macd_cross_val > i_mc_long ? 1.0 : 0.0
roc_vote  = roc_val < i_roc_short ? -1.0 : roc_val > i_roc_long ? 1.0 : 0.0

// Sum of votes
n_indicators = 7.0
vote_sum = emad_vote + st_vote + lr_vote + rsi_vote + ms_vote + mc_vote + roc_vote

// Majority vote
majority = n_indicators * i_threshold
final_signal = vote_sum > majority ? 1 : vote_sum < -majority ? -1 : 0

// Apply volume filter
filtered_signal = vol_ok ? final_signal : 0

// ══════════════════════════════════════════════════════════════════
// STRATEGY EXECUTION
// process_orders_on_close=false → orders fill at NEXT bar's open = 1-bar delay
// ══════════════════════════════════════════════════════════════════

var int entry_bar_index = 0

// No [1] shift needed: process_orders_on_close=false already delays execution by 1 bar
// (order placed at bar i close → fills at bar i+1 open = 1 bar delay like Python)

// Entry only from FLAT — matches Python (no flips when exit_on_signal_flip=false)
long_entry  = filtered_signal == 1 and strategy.position_size == 0
short_entry = filtered_signal == -1 and strategy.position_size == 0

// Max hold exit
bars_in_trade = bar_index - entry_bar_index
max_hold_exit = i_max_hold > 0 and strategy.position_size != 0 and bars_in_trade >= i_max_hold

// Signal flip exit (disabled by default in this strategy)
signal_flip_long  = i_exit_flip and strategy.position_size > 0 and filtered_signal == -1
signal_flip_short = i_exit_flip and strategy.position_size < 0 and filtered_signal == 1

// Position sizing: risk% × leverage
qty_pct = i_risk_pct * i_leverage / 100.0

// SL / TP prices
long_sl  = strategy.position_avg_price * (1 - i_sl_pct / 100)
long_tp  = strategy.position_avg_price * (1 + i_tp_pct / 100)
short_sl = strategy.position_avg_price * (1 + i_sl_pct / 100)
short_tp = strategy.position_avg_price * (1 - i_tp_pct / 100)

// ── CLOSE on signal flip / max hold ──
if signal_flip_long or signal_flip_short
    strategy.close_all(comment="Flip")
    
if max_hold_exit  
    strategy.close_all(comment="MaxHold")

// ── LONG ──
if long_entry and barstate.isconfirmed
    strategy.entry("L", strategy.long, qty=strategy.equity * qty_pct / close, 
                   comment="Long")
    entry_bar_index := bar_index

// ── SHORT ──
if short_entry and barstate.isconfirmed
    strategy.entry("S", strategy.short, qty=strategy.equity * qty_pct / close,
                   comment="Short")
    entry_bar_index := bar_index

// ── SL / TP ──
if strategy.position_size > 0
    strategy.exit("XL", "L", stop=long_sl, limit=long_tp,
                  comment_loss="SL", comment_profit="TP")

if strategy.position_size < 0
    strategy.exit("XS", "S", stop=short_sl, limit=short_tp,
                  comment_loss="SL", comment_profit="TP")

// ══════════════════════════════════════════════════════════════════
// VISUALS
// ══════════════════════════════════════════════════════════════════

// Background tint
bgcolor(filtered_signal == 1 ? color.new(color.green, 93) : 
        filtered_signal == -1 ? color.new(color.red, 93) : na, title="Signal BG")

// SuperTrend line
plot(st_line, "SuperTrend", color=supertrend_val > 0 ? color.green : color.red, 
     linewidth=2, display=display.pane)

// EMA Distance reference
plot(emad_ema, "EMA(100)", color=color.new(color.orange, 60), linewidth=1)

// Entry arrows
plotshape(long_entry and barstate.isconfirmed, "Long", shape.triangleup, 
          location.belowbar, color.new(color.green, 0), size=size.small)
plotshape(short_entry and barstate.isconfirmed, "Short", shape.triangledown, 
          location.abovebar, color.new(color.red, 0), size=size.small)

// ══════════════════════════════════════════════════════════════════
// DASHBOARD TABLE
// ══════════════════════════════════════════════════════════════════
var table dash = table.new(position.top_right, 2, 14, 
                           bgcolor=color.new(color.black, 80), 
                           border_color=color.gray, border_width=1)

if barstate.islast
    // Header
    table.cell(dash, 0, 0, "Strategy Lab v2", text_color=color.white, text_size=size.normal)
    table.cell(dash, 1, 0, "BTC 15m", text_color=color.yellow, text_size=size.normal)
    
    // Signal status
    sig_txt = filtered_signal == 1 ? "LONG" : filtered_signal == -1 ? "SHORT" : "FLAT"
    sig_col = filtered_signal == 1 ? color.green : filtered_signal == -1 ? color.red : color.gray
    table.cell(dash, 0, 1, "Signal", text_color=color.gray)
    table.cell(dash, 1, 1, sig_txt, text_color=sig_col)
    
    // Votes
    table.cell(dash, 0, 2, "Votes", text_color=color.gray)
    table.cell(dash, 1, 2, str.tostring(vote_sum, "#.#") + " / " + str.tostring(n_indicators, "#"), 
               text_color=vote_sum > 0 ? color.green : vote_sum < 0 ? color.red : color.gray)
    
    // Indicators
    table.cell(dash, 0, 3, "EMA Dist", text_color=color.gray)
    table.cell(dash, 1, 3, str.tostring(emad_vote, "#") + " (" + str.tostring(emad_val, "#.##") + ")", 
               text_color=emad_vote > 0 ? color.green : emad_vote < 0 ? color.red : color.gray)
    
    table.cell(dash, 0, 4, "SuperTrend", text_color=color.gray)
    table.cell(dash, 1, 4, str.tostring(st_vote, "#") + " (" + str.tostring(supertrend_val, "#") + ")", 
               text_color=st_vote > 0 ? color.green : st_vote < 0 ? color.red : color.gray)
    
    table.cell(dash, 0, 5, "LR Slope", text_color=color.gray)
    table.cell(dash, 1, 5, str.tostring(lr_vote, "#") + " (" + str.tostring(lr_val, "#.##") + ")", 
               text_color=lr_vote > 0 ? color.green : lr_vote < 0 ? color.red : color.gray)
    
    table.cell(dash, 0, 6, "RSI", text_color=color.gray)
    table.cell(dash, 1, 6, str.tostring(rsi_vote, "#") + " (" + str.tostring(rsi_raw, "#.#") + ")", 
               text_color=rsi_vote > 0 ? color.green : rsi_vote < 0 ? color.red : color.gray)
    
    table.cell(dash, 0, 7, "MACD Hist", text_color=color.gray)
    table.cell(dash, 1, 7, str.tostring(ms_vote, "#") + " (" + str.tostring(ms_val, "#.##") + ")", 
               text_color=ms_vote > 0 ? color.green : ms_vote < 0 ? color.red : color.gray)
    
    table.cell(dash, 0, 8, "MACD Cross", text_color=color.gray)
    table.cell(dash, 1, 8, str.tostring(mc_vote, "#") + " (" + str.tostring(macd_cross_val, "#") + ")", 
               text_color=mc_vote > 0 ? color.green : mc_vote < 0 ? color.red : color.gray)
    
    table.cell(dash, 0, 9, "ROC", text_color=color.gray)
    table.cell(dash, 1, 9, str.tostring(roc_vote, "#") + " (" + str.tostring(roc_val, "#.##") + ")", 
               text_color=roc_vote > 0 ? color.green : roc_vote < 0 ? color.red : color.gray)
    
    // Risk info
    table.cell(dash, 0, 10, "Vol Z", text_color=color.gray)
    table.cell(dash, 1, 10, str.tostring(vol_z, "#.##") + (vol_ok ? " OK" : " SKIP"), 
               text_color=vol_ok ? color.white : color.orange)
    
    table.cell(dash, 0, 11, "Leverage", text_color=color.gray)
    table.cell(dash, 1, 11, str.tostring(i_leverage, "#.#") + "x", text_color=color.yellow)
    
    table.cell(dash, 0, 12, "SL / TP", text_color=color.gray)
    table.cell(dash, 1, 12, str.tostring(i_sl_pct, "#.#") + "% / " + str.tostring(i_tp_pct, "#.#") + "%", text_color=color.white)
    
    table.cell(dash, 0, 13, "Bars Held", text_color=color.gray)
    table.cell(dash, 1, 13, strategy.position_size != 0 ? str.tostring(bars_in_trade) + "/" + str.tostring(i_max_hold) : "—", text_color=color.white)

// ══════════════════════════════════════════════════════════════════
// ALERTS
// ══════════════════════════════════════════════════════════════════
alertcondition(long_entry,  "Long Entry",  "Strategy Lab: LONG")
alertcondition(short_entry, "Short Entry", "Strategy Lab: SHORT")
alertcondition(max_hold_exit, "Max Hold",  "Strategy Lab: Max hold exit")
